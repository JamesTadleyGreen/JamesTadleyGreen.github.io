<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Part II: Search - James Green</title>
        <link rel="stylesheet" href="../../css/variables.css" />
        <link rel="stylesheet" href="../../css/default.css" />
        <link rel="stylesheet" href="../../css/syntax.css" />
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../../">James Tadley Green</a>
            </div>
            <nav>
                <a href="../../">Home</a>
                <a href="../../about.html">About</a>
                <a href="../../posts.html">Posts</a>
            </nav>
        </header>

        <main role="main">
            <h1>Part II: Search</h1>
            <link rel="stylesheet" href="../../css/toc.css" />
<table class="toc">
    <tbody>
    
        
            <tr>
                <td><a href="../../posts/the_last_algorithms_course/1-intro.html">1</a></td>
                <td><a href="../../posts/the_last_algorithms_course/1-intro.html">Part I: Intro</a></td>
            </tr>
        
    
        
            <tr class="active-row">
                <td><a href="../../posts/the_last_algorithms_course/2-search.html">2</a></td>
                <td><a href="../../posts/the_last_algorithms_course/2-search.html">Part II: Search</a></td>
            </tr>
        
    
    </tbody>
</table>

<link rel="stylesheet" href="../../css/post.css" />
<link rel="stylesheet" href="../../css/JetBrains-Mono.css" />
<!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous"> -->
<!-- <!-1- The loading of KaTeX is deferred to speed up page rendering -1-> -->
<!-- <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script> -->

<!-- <!-1- To automatically render math in text elements, include the auto-render extension: -1-> -->
<!-- <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" -->
<!--     onload="renderMathInElement(document.body);"></script> -->
<article>
    <section class="header">
        <ol class="post-info">
            
                <li>
                    Posted 2023-11-20 <svg class="w-6 h-6 text-gray-800 dark:text-white" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
    <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 10h16m-8-3V4M7 7V4m10 3V4M5 20h14c.6 0 1-.4 1-1V7c0-.6-.4-1-1-1H5a1 1 0 0 0-1 1v12c0 .6.4 1 1 1Zm3-7h0v0h0v0Zm4 0h0v0h0v0Zm4 0h0v0h0v0Zm-8 4h0v0h0v0Zm4 0h0v0h0v0Zm4 0h0v0h0v0Z"></path>
</svg>

                </li>
            
            
                <li>
                    5 minute read <svg class="w-6 h-6 text-gray-800 dark:text-white" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
    <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"></path>
</svg>

                </li>
            
            
                <li>
                    123 <svg class="w-6 h-6 text-gray-800 dark:text-white" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
    <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 8v8m0-8a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm0 8a2 2 0 1 0 0 4 2 2 0 0 0 0-4Zm8-8a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm0 0a4 4 0 0 1-4 4h-1a3 3 0 0 0-3 3"></path>
</svg>

                </li>
            
            
                <li>
                   #<a class="tag" href="../../tags/maths.html">maths</a> #<a class="tag" href="../../tags/algorithms.html">algorithms</a> #<a class="tag" href="../../tags/haskell.html">haskell</a> #<a class="tag" href="../../tags/search.html">search</a> <svg class="w-6 h-6 text-gray-800 dark:text-white" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
    <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.6 8.4h0m-4.7 11.3-6.6-6.6a1 1 0 0 1 0-1.4l7.3-7.4a1 1 0 0 1 .7-.3H18a2 2 0 0 1 2 2v5.5a1 1 0 0 1-.3.7l-7.5 7.5a1 1 0 0 1-1.3 0Z"></path>
</svg>

                </li>
            
        </ol>
    </section>
    <section>
        <blockquote>
<p>We look a two different searches, one on a sorted list, and finish with a brainteaser.</p>
</blockquote>
<h1 data-number="1" id="linear-search"><span class="header-section-number">1</span> Linear Search</h1>
<p>Currently I want to write in Haskell, mainly because it’s ‘mathsy’. It’s been a while
so my first attempt looks like this.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">linearSearch ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>linearSearch as s <span class="ot">=</span> linearSearch' as s <span class="dv">0</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="ot">linearSearch' ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>linearSearch' (a<span class="op">:</span>as) s i</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> a <span class="op">==</span> s    <span class="ot">=</span> i</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> linearSearch' a as (i<span class="op">+</span><span class="dv">1</span>)</span></code></pre></div>
<p>As soon as I wrote this, I remembered folds exist. Thus my second attempt was.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">linearSearch ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>linearSearch as s <span class="ot">=</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fst</span> <span class="op">$</span> <span class="fu">foldl</span> (\(i, b) x <span class="ot">-&gt;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> b</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>            <span class="kw">then</span> (i,<span class="dt">True</span>)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>            <span class="kw">if</span> x <span class="op">==</span> s</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>                <span class="kw">then</span> (i, <span class="dt">True</span>)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>            <span class="kw">else</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>                (i <span class="op">+</span> <span class="dv">1</span>, <span class="dt">False</span>))</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        (<span class="dv">0</span>, <span class="dt">False</span>) as</span></code></pre></div>
<p>Well that was gross, firstly if the list is empty, the search returns 0.
Secondly, if the search fails, it returns the length of the list.
Thirdly, it doesn’t short circuit.
Finally, it’s just super gross to look at from a code perspective.</p>
<p>Both are <span class="math inline">\(\mathcal{O}(n)\)</span>, which is good!</p>
<p>Now I watch a little more and it turns out we don’t need the index! We only need to
return a <code>bool</code> indicating if the search was successful.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">linearSearch ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>linearSearch [] _ <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>linearSearch (a<span class="op">:</span>as) s</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> a <span class="op">==</span> s    <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> linearSearch as s</span></code></pre></div>
<h2 data-number="1.1" id="notes"><span class="header-section-number">1.1</span> Notes</h2>
<p><em>Had a <a href="https://stackoverflow.com/questions/52518817/haskell-linear-search-returning-index">google</a>
after the event, I should be returning a <code>Maybe Int</code> in my first attempts.
Using fmap to lift the <code>(+1)</code> into the <code>Just</code> is something I would have missed.</em></p>
<h1 data-number="2" id="binary-search"><span class="header-section-number">2</span> Binary Search</h1>
<p>Things get a bit more orderly here. We assume we have ordered lists. Thus, our function
type is going to change. It’s going to be <code>Ord a =&gt; [a] -&gt; a -&gt; Int</code>. I love Hasekll
for exactly this reason. The type signature is giving such a breadth of information for
free, allowing less cognitive overhead.</p>
<p>My first attempt is as follows:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">binarySearch ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>binarySearch as s <span class="ot">=</span> binarySearch' as <span class="dv">0</span> (<span class="fu">length</span> as) s</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="ot">binarySearch' ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>binarySearch' as lo hi s</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a> <span class="op">|</span> lo <span class="op">==</span> hi  <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a> <span class="op">|</span> s <span class="op">==</span> v    <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a> <span class="op">|</span> s <span class="op">&gt;</span> v     <span class="ot">=</span> binarySearch' as (m<span class="op">+</span><span class="dv">1</span>) hi s</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a> <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> binarySearch' as lo m s</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span> m <span class="ot">=</span> lo <span class="op">+</span> (hi <span class="op">-</span> lo) <span class="ot">`div`</span> <span class="dv">2</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>       v <span class="ot">=</span> as <span class="op">!!</span> m</span></code></pre></div>
<p>Interestingly The Primeagen uses <code>lo &lt; hi</code> this confuses me, I can’t think of a
situation where this could possibly occur. So I’ll leave mine as is.</p>
<h2 data-number="2.1" id="notes-1"><span class="header-section-number">2.1</span> Notes</h2>
<p>Using <a href="https://codereview.stackexchange.com/questions/158096/binary-search-in-haskell">StackOverflow</a>
I see I should have used <code>quot</code> instead of <code>div</code>. This is due to
<a href="https://stackoverflow.com/questions/8111120/integral-operators-quot-vs-div">this answer</a>
regarding speed of the operations.</p>
<p>My implementation of this looks close enough that I am happy.</p>
<h1 data-number="3" id="two-crystal-problem"><span class="header-section-number">3</span> Two Crystal Problem</h1>
<p>First impressions, this is cool. It’s very much similar to maths problems I’ve done in
interviews before. Second impression, i need to give this some thought. It’s
obviously a binary search, but exactly how isn’t obvious.</p>
<p>We can’t ‘hit’ the max more than once, else we have no more balls. Some scenarios:</p>
<ul>
<li>We drop from floor 3 and it breaks
<ul>
<li>We then have to drop the ball from the 1st floor, else if it breaks on the second
we don’t know if it’d break on the first.</li>
<li>This generalises to, if our first ball breaks, we’re subject to using <a href="#linear-search">linear search</a>.</li>
</ul></li>
<li>I think the general tactic, is that we want the number of subdivisions to equal the
length of the linear search.
<ul>
<li>For example, with 10 floors this would be thirds, if our ball breaks on the first
bounce, we have two additional checks.</li>
<li>For any additional break we still have two additional checks.</li>
</ul></li>
<li>This means for x floors we want to have <span class="math inline">\(\sqrt{x}\)</span> subdivisions.</li>
</ul>
<p>This logic is probably “off-by-one” somewhere but I give up thinking about it any more!</p>
<blockquote>
<p>Welp, got that one right in one.</p>
</blockquote>
<p>After his explanation there was one bit I wasn’t quite satisfied with, why <span class="math inline">\(\sqrt[3]{x}\)</span>
doesn’t work as well. While I don’t think it’s as bad as <span class="math inline">\(\mathcal{O}(n)\)</span> I think
it’s worse than <span class="math inline">\(\mathcal{O}(\sqrt{n})\)</span>.</p>
<p>Let’s consider <span class="math inline">\(\sqrt[3]{x}\)</span>, whilst our linear search becomes smaller. Our jumps
do also, we have to do <span class="math inline">\(\sqrt[3]x^2\)</span> jumps. In general, for an <span class="math inline">\(i^{th}\)</span> power
we have a run time of <span class="math inline">\(x^{(1/i)} + x^{(1 - 1/i)}\)</span>. We want to minimise this,
which is just when the two terms are equal (big-<span class="math inline">\(\mathcal{O}\)</span> notation ‘takes’ only
the largest term), <em>i.e. taking the square-root</em>.</p>
<p>Let’s implement, we can do this in a really nice general way (and re-implement binary
search).</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">generalisedSearch ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>generalisedSearch fs as s <span class="ot">=</span> generalisedSearch' fs as <span class="dv">0</span> (<span class="fu">length</span> as) s</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="ot">generalisedSearch' ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>generalisedSearch' (f<span class="op">:</span>fs) as lo hi s</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a> <span class="op">|</span> lo <span class="op">==</span> hi  <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a> <span class="op">|</span> s <span class="op">==</span> v    <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a> <span class="op">|</span> s <span class="op">&gt;</span> v     <span class="ot">=</span> generalisedSearch' (f<span class="op">:</span>fs) as (m<span class="op">+</span><span class="dv">1</span>) hi s</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a> <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> generalisedSearch' fs as lo m s</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span> m <span class="ot">=</span> f lo hi</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>       v <span class="ot">=</span> as <span class="op">!!</span> m</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a><span class="ot">binarySearch ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>binarySearch <span class="ot">=</span> generalisedSearch <span class="op">$</span> <span class="fu">repeat</span> <span class="op">$</span> \lo hi <span class="ot">-&gt;</span> lo <span class="op">+</span> (hi <span class="op">-</span> lo) <span class="ot">`quot`</span> <span class="dv">2</span></span></code></pre></div>
<p>Thus, our <code>crystalSearch</code> becomes:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">crystalSearch ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>crystalSearch <span class="ot">=</span> generalisedSearch [\lo hi <span class="ot">-&gt;</span> <span class="fu">min</span> (lo <span class="op">+</span> isqrt hi) (hi <span class="op">-</span><span class="dv">1</span>), \lo hi <span class="ot">-&gt;</span> lo <span class="op">+</span> <span class="dv">1</span>]</span></code></pre></div>
<p>The <code>min</code> in there is vile, and also shows that I’m too tired and shouldn’t be doing
at 11:30 at night. But we have generalised fairly well!</p>
<p>Looking at The Primeagen’s solution, he’s hidden away this <code>min</code> function, but has a
similar implementation.</p>
    </section>
</article>


        </main>

        <footer>
            © 2023, James Green
        </footer>
    </body>
</html>
