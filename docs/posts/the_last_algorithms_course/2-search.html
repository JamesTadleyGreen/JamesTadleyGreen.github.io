<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Search - James Green</title>
        <link rel="stylesheet" href="../../css/default.css" />
        <link rel="stylesheet" href="../../css/syntax.css" />
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../../">James Tadley Green</a>
            </div>
            <nav>
                <a href="../../">Home</a>
                <a href="../../about.html">About</a>
                <a href="../../posts.html">Posts</a>
            </nav>
        </header>

        <main role="main">
            <h1>Search</h1>
            <link rel="stylesheet" href="../../css/toc.css" />
<table class="toc">
    <tbody>
    
        
            <tr>
                <td><a href="../../posts/the_last_algorithms_course/1-intro.html">1</a></td>
                <td><a href="../../posts/the_last_algorithms_course/1-intro.html">Intro</a></td>
            </tr>
        
    
        
            <tr class="active-row">
                <td><a href="../../posts/the_last_algorithms_course/2-search.html">2</a></td>
                <td><a href="../../posts/the_last_algorithms_course/2-search.html">Search</a></td>
            </tr>
        
    
    </tbody>
</table>

<link rel="stylesheet" href="../../css/post.css" />
<link rel="stylesheet" href="../../css/JetBrains-Mono.css" />
<article>
    <section class="header">
        Posted on 1st January 2020
        <br>
        
           Tags: maths, algorithms, haskell, search
        
    </section>
    <section>
        <h1 id="search">Search</h1>
<h2 id="linear-search">Linear Search</h2>
<p>Currently I want to write in Haskell, mainly because it‚Äôs ‚Äòmathsy‚Äô. It‚Äôs been a while
so my first attempt looks like this.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">linearSearch ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>linearSearch as s <span class="ot">=</span> linearSearch' as s <span class="dv">0</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="ot">linearSearch' ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>linearSearch' (a<span class="op">:</span>as) s i</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> a <span class="op">==</span> s    <span class="ot">=</span> i</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> linearSearch' a as (i<span class="op">+</span><span class="dv">1</span>)</span></code></pre></div>
<p>As soon as I wrote this, I remembered folds exist. Thus my second attempt was.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">linearSearch ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>linearSearch as s <span class="ot">=</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fst</span> <span class="op">$</span> <span class="fu">foldl</span> (\(i, b) x <span class="ot">-&gt;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> b</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>            <span class="kw">then</span> (i,<span class="dt">True</span>)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>            <span class="kw">if</span> x <span class="op">==</span> s</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>                <span class="kw">then</span> (i, <span class="dt">True</span>)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>            <span class="kw">else</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>                (i <span class="op">+</span> <span class="dv">1</span>, <span class="dt">False</span>))</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        (<span class="dv">0</span>, <span class="dt">False</span>) as</span></code></pre></div>
<p>Well that was gross, firstly if the list is empty, the search returns 0.
Secondly, if the search fails, it returns the length of the list.
Thirdly, it doesn‚Äôt short circuit.
Finally, it‚Äôs just super gross to look at from a code perspective.</p>
<p>Both are <span class="math inline">ùí™(<em>n</em>)</span>, which is good!</p>
<p>Now I watch a little more and it turns out we don‚Äôt need the index! We only need to
return a <code>bool</code> indicating if the search was successful.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">linearSearch ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>linearSearch [] _ <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>linearSearch (a<span class="op">:</span>as) s</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> a <span class="op">==</span> s    <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> linearSearch as s</span></code></pre></div>
<h3 id="notes">Notes</h3>
<p>Had a <a href="https://stackoverflow.com/questions/52518817/haskell-linear-search-returning-index">google</a>
after the event, I should be returning a <code>Maybe Int</code> in my first attempts.
Using fmap to lift the <code>(+1)</code> into the <code>Just</code> is something I would have missed.</p>
<h2 id="binary-search">Binary Search</h2>
<p>Things get a bit more orderly here. We assume we have ordered lists. Thus, our function
type is going to change. It‚Äôs going to be <code>Ord a =&gt; [a] -&gt; a -&gt; Int</code>. I love Hasekll
for exactly this reason. The type signature is giving such a breadth of information for
free, allowing less cognitive overhead.</p>
<p>My first attempt is as follows:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">binarySearch ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>binarySearch as s <span class="ot">=</span> binarySearch' as <span class="dv">0</span> (<span class="fu">length</span> as) s</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="ot">binarySearch' ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>binarySearch' as lo hi s</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a> <span class="op">|</span> lo <span class="op">==</span> hi  <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a> <span class="op">|</span> s <span class="op">==</span> v    <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a> <span class="op">|</span> s <span class="op">&gt;</span> v     <span class="ot">=</span> binarySearch' as (m<span class="op">+</span><span class="dv">1</span>) hi s</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a> <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> binarySearch' as lo m s</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span> m <span class="ot">=</span> lo <span class="op">+</span> (hi <span class="op">-</span> lo) <span class="ot">`div`</span> <span class="dv">2</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>       v <span class="ot">=</span> as <span class="op">!!</span> m</span></code></pre></div>
<p>Interestingly The Primeagen uses <code>lo &lt; hi</code> this confuses me, I can‚Äôt think of a
situation where this could possibly occur. So I‚Äôll leave mine as is.</p>
<h3 id="notes-1">Notes</h3>
<p>Using <a href="https://codereview.stackexchange.com/questions/158096/binary-search-in-haskell">StackOverflow</a>
I see I should have used <code>quot</code> instead of <code>div</code>. This is due to
<a href="https://stackoverflow.com/questions/8111120/integral-operators-quot-vs-div">this answer</a>
regarding speed of the operations.</p>
<p>My implementation of this looks close enough that I am happy.</p>
<h2 id="two-crystal-problem">Two Crystal Problem</h2>
<p>First impressions, this is cool. It‚Äôs very much similar to maths problems I‚Äôve done in
interviews before. Second impression, i need to give this some thought. It‚Äôs
obviously a binary search, but exactly how isn‚Äôt obvious.</p>
<p>We can‚Äôt ‚Äòhit‚Äô the max more than once, else we have no more balls. Some scenarios:
- We drop from floor 3 and it breaks
- We then have to drop the ball from the 1st floor, else if it breaks on the second
we don‚Äôt know if it‚Äôd break on the first.
- This generalises to, if our first ball breaks, we‚Äôre subject to using <a href="#linear-search">linear search</a>.
- I think the general tactic, is that we want the number of subdivisions to equal the
length of the linear search.
- For example, with 10 floors this would be thirds, if our ball breaks on the first
bounce, we have two additional checks.
- For any additional break we still have two additional checks.
- This means for x floors we want to have \(\) subdivisions.</p>
<p>This logic is probably ‚Äúoff-by-one‚Äù somewhere but I give up thinking about it any more!</p>
<p><em>Welp, got that one right in one.</em></p>
<p>After his explanation there was one bit I wasn‚Äôt quite satisfied with, why \(\)
doesn‚Äôt work as well. While I don‚Äôt think it‚Äôs as bad as \((n)\) I think
it‚Äôs worse than \(()\).</p>
<p>Let‚Äôs consider \(\), whilst our linear search becomes smaller. Our jumps
do also, we have to do \(^2\) jumps. In general, for an \(i^th\) power
we have a run time of \(x^(1/i) + x^(1 - i/1)\). We want to minimise this,
which is just when the two terms are equal (big-\(\) notation ‚Äòtakes‚Äô only
the largest term), <em>i.e.</em> taking the square-root.</p>
<p>Let‚Äôs implement, we can do this in a really nice general way (and re-implement binary
search).</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">generalisedSearch ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>generalisedSearch fs as s <span class="ot">=</span> generalisedSearch' fs as <span class="dv">0</span> (<span class="fu">length</span> as) s</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="ot">generalisedSearch' ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>generalisedSearch' (f<span class="op">:</span>fs) as lo hi s</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a> <span class="op">|</span> lo <span class="op">==</span> hi  <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a> <span class="op">|</span> s <span class="op">==</span> v    <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a> <span class="op">|</span> s <span class="op">&gt;</span> v     <span class="ot">=</span> generalisedSearch' (f<span class="op">:</span>fs) as (m<span class="op">+</span><span class="dv">1</span>) hi s</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a> <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> generalisedSearch' fs as lo m s</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span> m <span class="ot">=</span> f lo hi</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>       v <span class="ot">=</span> as <span class="op">!!</span> m</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a><span class="ot">binarySearch ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>binarySearch <span class="ot">=</span> generalisedSearch <span class="op">$</span> <span class="fu">repeat</span> <span class="op">$</span> \lo hi <span class="ot">-&gt;</span> lo <span class="op">+</span> (hi <span class="op">-</span> lo) <span class="ot">`quot`</span> <span class="dv">2</span></span></code></pre></div>
<p>Thus, our <code>crystalSearch</code> becomes:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">crystalSearch ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>crystalSearch <span class="ot">=</span> generalisedSearch [\lo hi <span class="ot">-&gt;</span> <span class="fu">min</span> (lo <span class="op">+</span> isqrt hi) (hi <span class="op">-</span><span class="dv">1</span>), \lo hi <span class="ot">-&gt;</span> lo <span class="op">+</span> <span class="dv">1</span>]</span></code></pre></div>
<p>The <code>min</code> in there is vile, and also shows that I‚Äôm too tired and shouldn‚Äôt be doing
at 11:30 at night. But we have generalised fairly well!</p>
<p>Looking at The Primeagen‚Äôs solution, he‚Äôs hidden away this <code>min</code> function, but has a
similar implementation.</p>
    </section>
</article>


        </main>

        <footer>
            ¬© 2023, James Green
        </footer>
    </body>
</html>
